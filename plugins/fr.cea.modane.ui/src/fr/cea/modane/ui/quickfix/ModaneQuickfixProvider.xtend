/*
* generated by Xtext
*/
package fr.cea.modane.ui.quickfix

import fr.cea.modane.modane.ArgDefinition
import fr.cea.modane.modane.Function
import fr.cea.modane.modane.ModaneFactory
import fr.cea.modane.modane.NamedElement
import fr.cea.modane.modane.ServiceOrModule
import fr.cea.modane.validation.ModaneValidator
import org.eclipse.xtext.ui.editor.quickfix.DefaultQuickfixProvider
import org.eclipse.xtext.ui.editor.quickfix.Fix
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor
import org.eclipse.xtext.validation.Issue

import static extension fr.cea.modane.InterfaceExtensions.*

/**
 * Custom quickfixes.
 *
 * see http://www.eclipse.org/Xtext/documentation.html#quickfixes
 */
class ModaneQuickfixProvider extends DefaultQuickfixProvider 
{
	@Fix(ModaneValidator::INVALID_NAME)
	def applyClassRuleName(Issue issue, IssueResolutionAcceptor acceptor) 
	{
		if (issue.data === null || issue.data.length != 1) return

		val label = 'Régulariser le nom'
		acceptor.accept(issue, label, label, null) [
			element, context |
			(element as NamedElement).name = issue.data.head
		]
	}

	/**
	 * Remplace le retour de la fonction par 'void'.
	 * Le paramètre issue est sur le type de retour, par exemple Real.
	 * Le problème est que le retour peut avoir une cardinalité multiple, [0..*].
	 * Il faut donc rechercher cette cardinalité et son offset pour l'enlever.
	 */
	@Fix(ModaneValidator::RETURN_VOID)
	def forceVoid(Issue issue, IssueResolutionAcceptor acceptor) 
	{
		val label = 'Forcer le type de retour à void'
		acceptor.accept(issue, label, label, null) [
			element, context |
			(element as Function).type = null
		]	
	}
	
	/**
	 * Supprime la valeur par défaut sur un argument autre qu'en entrée
	 */
	@Fix(ModaneValidator::INCORRECT_DEFAULT_VALUE)
	def suppressDefaultValue(Issue issue, IssueResolutionAcceptor acceptor)
	{
		val label = 'Supprimer la valeur par défaut'
		acceptor.accept(issue, label, label, null) [
			element, context |
			(element as ArgDefinition).defaultValue = null
		]
	}
	
	@Fix(ModaneValidator::IMPLEMENT_FUNCTIONS)
	def insertOverrideFunctions(Issue issue, IssueResolutionAcceptor acceptor) 
	{
		val label = 'Implémenter toutes les fonctions manquantes'
		acceptor.accept(issue, label, label, null) [
			element, context |
			val sOrM = element as ServiceOrModule
			for (i : sOrM.interfaces)
				for (f : i.allFunctions)
					if (!sOrM.overrideFuncs.exists[o | o.func == f]) 
					{
						val o = ModaneFactory::eINSTANCE.createOverrideFunction
						o.func = f
						sOrM.overrideFuncs += o
					}
		]
	}
}
