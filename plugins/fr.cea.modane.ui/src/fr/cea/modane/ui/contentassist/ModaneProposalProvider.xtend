/*
 * generated by Xtext
 */
package fr.cea.modane.ui.contentassist

import com.google.common.base.Predicate
import com.google.inject.Inject
import fr.cea.modane.Utils
import fr.cea.modane.modane.Function
import fr.cea.modane.modane.Interface
import fr.cea.modane.modane.ModanePackage
import fr.cea.modane.modane.Module
import fr.cea.modane.modane.OverrideFunction
import fr.cea.modane.modane.Pty
import fr.cea.modane.modane.Reference
import fr.cea.modane.modane.Service
import java.util.ArrayList
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.CrossReference
import org.eclipse.xtext.RuleCall
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor

import static extension fr.cea.modane.ModaneModelExtensions.*
import static extension fr.cea.modane.ModaneElementExtensions.*

/**
 * see http://www.eclipse.org/Xtext/documentation/latest/xtext.html#contentAssist on how to customize content assistant
 */
class ModaneProposalProvider extends AbstractModaneProposalProvider 
{
	@Inject IQualifiedNameProvider nameProvider

	// --**-- Méthodes de type complete{TypeName}_{FeatureName}
	override completeOverrideFunction_Func(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) 
	{
		val of = model as OverrideFunction
		val functionNames = new ArrayList<String>
		for (i : of.eContainer.interfaces)
			for (f : i.functions)
				functionNames.addAll(nameProvider.getFullyQualifiedName(f).toString)
		
		val pred = new NamesFilterPredicate(functionNames)
		lookupCrossReference(assignment.terminal as CrossReference, context, acceptor, pred)
	}
	
	/** Filtrage des variables si la fonction est définie sur une interface */
	override completeVarReference_Variable(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor)
	{
		// pas de proposition de complétion si c'esy une fonction d'interface (pas le droit au VarReference
		if (!(model instanceof Function) || !(model.eContainer instanceof Interface))
			super.completeVarReference_Variable(model, assignment, context, acceptor)
	}
	
	override completePty_DefaultValue(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor)
	{
		val pty = model as Pty
		if (pty.type instanceof Reference && (pty.type as Reference).target instanceof Interface)
		{
			val interf = (pty.type as Reference).target as Interface
			val services = Utils::getAllElementsOfType(scopeProvider, model, ModanePackage::eINSTANCE.service)
			for (s : services)
			{
				val service = s as Service
				if (service.interfaces.contains(interf))
				{
					val name = '"' + service.model.name + '.' + service.name + '"'
					acceptor.accept(createCompletionProposal(name, context))	
				}	
			}
		}
		else super.completePty_DefaultValue(model, assignment, context, acceptor)	
	}
	
	// --**-- Méthodes de type complete_{RuleName}
	override complete_QualifiedName(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor)
	{
		val scope = scopeProvider.getScope(model, ModanePackage::eINSTANCE.modaneModel_Elements)
		scope.modelNames.forEach[p | acceptor.accept(createCompletionProposal(p + '.', context))]
	}
	
	private def dispatch List<Interface> getInterfaces(Module it) { interfaces }
	private def dispatch List<Interface> getInterfaces(Service it) { interfaces }
	private def dispatch List<Interface> getInterfaces(EObject it) { null }
}

class NamesFilterPredicate implements Predicate<IEObjectDescription>
{
	val List<String> names
	
	new(List<String> names) { this.names = names }
	override apply(IEObjectDescription input) { names.contains(input.name.toString) }
	override equals(Object input)  { true }
}

